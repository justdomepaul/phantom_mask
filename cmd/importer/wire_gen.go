// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"encoding/json"
	"github.com/google/uuid"
	"github.com/google/wire"
	"github.com/justdomepaul/toolbox/config"
	"github.com/justdomepaul/toolbox/database/spanner"
	"github.com/justdomepaul/toolbox/zap"
	zap2 "go.uber.org/zap"
	"os"
	"phantom_mask/internal/entity"
	spanner2 "phantom_mask/internal/storage/spanner"
	"phantom_mask/internal/utils"
	"time"
)

// Injectors from wire.go:

func Runner() (Empty, func(), error) {
	set, err := config.NewSet()
	if err != nil {
		return Empty{}, nil, err
	}
	core := config.NewCore(set)
	logger, err := zap.NewLogger(core)
	if err != nil {
		return Empty{}, nil, err
	}
	context := ctx()
	configSpanner := config.NewSpanner(set)
	iSession, cleanup, err := spanner.NewExtendSpannerDatabase(logger, configSpanner)
	if err != nil {
		return Empty{}, nil, err
	}
	pharmacy := spanner2.NewPharmacy(logger, iSession)
	pharmacyInfo := spanner2.NewPharmacyInfo(logger, iSession)
	product := spanner2.NewProduct(logger, iSession)
	user := spanner2.NewUser(logger, iSession)
	purchaseHistory := spanner2.NewPurchaseHistory(logger, iSession)
	spannerSet := spanner2.Set{
		Pharmacy:        pharmacy,
		PharmacyInfo:    pharmacyInfo,
		Product:         product,
		User:            user,
		PurchaseHistory: purchaseHistory,
	}
	importData := NewImportData(context, spannerSet)
	empty, cleanup2, err := Run(logger, set, importData)
	if err != nil {
		cleanup()
		return Empty{}, nil, err
	}
	return empty, func() {
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

func ctx() context.Context {
	return context.Background()
}

var ctxSet = wire.NewSet(ctx)

var LoggerSet = wire.NewSet(zap.NewLogger)

type Empty struct{}

func NewImportData(c context.Context, db spanner2.Set) *ImportData {
	return &ImportData{
		ctx: c,
		db:  db,
	}
}

type ImportData struct {
	ctx context.Context
	db  spanner2.Set
}

func (i ImportData) Init() error {
	var users []entity.UserJSON
	var pharmacies []entity.PharmacyJSON

	userFile, err := os.Open("./data/users.json")
	if err != nil {
		return err
	}
	defer userFile.Close()
	if err := json.NewDecoder(userFile).Decode(&users); err != nil {
		return err
	}
	pharmacyFile, err := os.Open("./data/pharmacies.json")
	if err != nil {
		panic(err)
	}
	defer pharmacyFile.Close()
	if err := json.NewDecoder(pharmacyFile).Decode(&pharmacies); err != nil {
		return err
	}

	pharmacyMap := map[string][]byte{}
	productMap := map[string][]byte{}

	for _, phy := range pharmacies {
		phyUID, err := uuid.NewUUID()
		if err != nil {
			return err
		}
		if err := i.db.Pharmacy.Create(i.ctx, entity.Pharmacy{
			UID:         phyUID[:],
			Name:        phy.Name,
			CashBalance: phy.CashBalance,
		}); err != nil {
			return err
		}
		pharmacyMap[phy.Name] = phyUID[:]

		openCloseHour, err := utils.ParseTimeFormat(phy.OpeningHours)
		if err != nil {
			return err
		}
		for _, info := range openCloseHour {
			if err := i.db.PharmacyInfo.Create(i.ctx, entity.PharmacyInfo{
				UID:       phyUID[:],
				Day:       info.Day,
				OpenHour:  info.OpenHour,
				CloseHour: info.CloseHour,
			}); err != nil {
				return err
			}
		}

		for _, mask := range phy.Masks {
			productUID, err := uuid.NewUUID()
			if err != nil {
				return err
			}
			if err := i.db.Product.Create(i.ctx, entity.Product{
				UID:       phyUID[:],
				ProductID: productUID[:],
				Name:      mask.Name,
				Price:     mask.Price,
			}); err != nil {
				return err
			}
			productMap[mask.Name] = productUID[:]
		}
	}

	for _, us := range users {
		userID, err := uuid.NewUUID()
		if err != nil {
			panic(err)
		}
		if err := i.db.User.Create(i.ctx, entity.User{
			UID:         userID[:],
			Name:        us.Name,
			CashBalance: us.CashBalance,
		}); err != nil {
			return err
		}
		for _, usHis := range us.PurchaseHistories {
			specifyTime, err := time.Parse("2006-01-02 15:04:05", usHis.TransactionDate)
			if err != nil {
				return err
			}
			if err := i.db.PurchaseHistory.Create(i.ctx, entity.PurchaseHistory{
				UID:               userID[:],
				PharmacyUID:       pharmacyMap[usHis.PharmacyName],
				ProductID:         productMap[usHis.MaskName],
				TransactionAmount: usHis.TransactionAmount,
				TransactionDate:   specifyTime,
			}); err != nil {
				return err
			}
		}
	}

	return nil
}

func Run(logger *zap2.Logger, coreOptions config.Set, initData *ImportData) (Empty, func(), error) {
	if err := initData.Init(); err != nil {
		return Empty{}, nil, err
	}
	return Empty{}, func() {}, nil
}
