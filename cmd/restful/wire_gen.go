// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/gin-contrib/pprof"
	"github.com/gin-gonic/gin"
	"github.com/google/wire"
	"github.com/justdomepaul/toolbox/config"
	"github.com/justdomepaul/toolbox/database/spanner"
	"github.com/justdomepaul/toolbox/jwt"
	"github.com/justdomepaul/toolbox/restful"
	"github.com/justdomepaul/toolbox/stringtool"
	"github.com/justdomepaul/toolbox/zap"
	zap2 "go.uber.org/zap"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"net/http"
	"phantom_mask/internal/handler"
	spanner2 "phantom_mask/internal/storage/spanner"
)

// Injectors from wire.go:

func RestfulRunner() (Empty, func(), error) {
	set, err := config.NewSet()
	if err != nil {
		return Empty{}, nil, err
	}
	core := config.NewCore(set)
	logger, err := zap.NewLogger(core)
	if err != nil {
		return Empty{}, nil, err
	}
	render := restful.NewRender()
	configJWT := config.NewJWT(set)
	ehs384JWT, err := jwt.NewEHS384JWTFromOptions(configJWT)
	if err != nil {
		return Empty{}, nil, err
	}
	basicGuardValidator := restful.NewBasicGuardValidator(ehs384JWT)
	jwtGuarder := restful.NewJWTGuarder(configJWT, basicGuardValidator)
	engine, err := restful.NewGin(set, render, jwtGuarder)
	if err != nil {
		return Empty{}, nil, err
	}
	commonHandler := _wireCommonHandlerValue
	configSpanner := config.NewSpanner(set)
	iSession, cleanup, err := spanner.NewExtendSpannerDatabase(logger, configSpanner)
	if err != nil {
		return Empty{}, nil, err
	}
	pharmacy := spanner2.NewPharmacy(logger, iSession)
	pharmacyInfo := spanner2.NewPharmacyInfo(logger, iSession)
	product := spanner2.NewProduct(logger, iSession)
	user := spanner2.NewUser(logger, iSession)
	purchaseHistory := spanner2.NewPurchaseHistory(logger, iSession)
	spannerSet := spanner2.Set{
		Pharmacy:        pharmacy,
		PharmacyInfo:    pharmacyInfo,
		Product:         product,
		User:            user,
		PurchaseHistory: purchaseHistory,
	}
	handlerPharmacy, err := handler.NewPharmacy(logger, spannerSet)
	if err != nil {
		cleanup()
		return Empty{}, nil, err
	}
	transaction, err := handler.NewTransaction(logger, spannerSet)
	if err != nil {
		cleanup()
		return Empty{}, nil, err
	}
	handlerSet := handler.Set{
		Pharmacy:    handlerPharmacy,
		Transaction: transaction,
	}
	empty, cleanup2, err := RunRestfulServer(logger, set, engine, commonHandler, handlerSet)
	if err != nil {
		cleanup()
		return Empty{}, nil, err
	}
	return empty, func() {
		cleanup2()
		cleanup()
	}, nil
}

var (
	_wireCommonHandlerValue = restful.CommonHandler{
		Error404:   restful.Error404Set,
		QuickReply: restful.QuickReplySet,
		PromHTTP:   restful.NewPromHTTPSet,
	}
)

// wire.go:

func ctx() context.Context {
	return context.Background()
}

var ctxSet = wire.NewSet(ctx)

var LoggerSet = wire.NewSet(zap.NewLogger)

type Empty struct{}

func RunRestfulServer(logger *zap2.Logger, coreOptions config.Set, route *gin.Engine, commonHandler restful.CommonHandler, handlers handler.Set) (Empty, func(), error) {
	handler.AddRoutes(route, commonHandler, handlers)
	pprof.Register(route)

	h2s := &http2.Server{}

	httpServer := &http.Server{
		Addr:    stringtool.StringJoin(":" + coreOptions.Server.Port),
		Handler: h2c.NewHandler(route, h2s),
	}

	go func(s *http.Server) {
		logger.Info("start restful server", zap2.String("system", coreOptions.Core.SystemName), zap2.String("port", coreOptions.Server.Port))
		if err := s.ListenAndServe(); err != nil {
			logger.Warn("restful server error or closed", zap2.String("system", coreOptions.Core.SystemName), zap2.Error(err))
		}
	}(httpServer)

	return Empty{}, func() {
		ctx2, cancel := context.WithTimeout(context.Background(), coreOptions.Server.ServerTimeout)
		defer cancel()
		if err := httpServer.Shutdown(ctx2); err != nil {
			logger.Warn("restful server Failed to Shutdown", zap2.String("system", coreOptions.Core.SystemName), zap2.Error(err))
		}
	}, nil
}
